---
position: 3
title: Bytecode Instructions
tags: [specification, spec, interpreter, bytecode, instructions]
---

## Bytecode Definition

A bytecode is a sequence of bytes. We always have one `opcode` that is followed by zero or more `operands`.
Lets take a look at an example. We have a simple bytecode. We push two bytes onto the stack and add them together.

The code would look like this:

```bash
# Stack []
bpush 1
# Stack [1]
bpush 2
# Stack [1, 2]
badd
# Stack [3]
```

The bytecode would look like this (byte values are written in hexadecimal):

```txt
01 01 01 02 10
```

Lets group the bytes a little bit to make it more readable:

```txt
01 01
01 02
10
```

We start the interpretation at the first byte. It is the opcode `bpush`. The interpreter knows that the opcode
`bpush` is always followed by a operand. So it reads the next byte and interprets it as the operand. The instruction
tells it to push this byte onto the stack. The pointer is now at the third byte. As we are finished with the first instruction by now, the next byte is interpreted as an opcode again.

_(The interpreter will do the same for the next instruction, it is `bpush` again, so it will do basically the same as
for the first instruction.)_

After the second `bpush` instruction, the pointer is at the fifth byte. The next byte is the opcode `badd`. The
interpreter knows that the opcode `badd` is not followed by any operand. The instruction tells it to add the two bytes
on top of the stack together and push the result onto the stack. The pointer is incremented again. This code is _bad_ as the pointer is now at the end of the bytecode, but we have no `RET` instruction. The interpreter will throw an error. But for this example that should be enough.

_**Keep in mind, that mistakes in the bytecode can lead to undefined behavior. If we have a byte missing, value bytes
can be interpreted as opcodes and vice versa. This is a serious problem and leads to many security issues, especially
when we can modify operand bytes during runtime. So be careful when you write your own bytecode (or use tools and not
write the bytes by hand).**_

In the following sections we will define the opcodes and operands they are followed by.

## Stack and variable manipulation

The stack hereby refers to a stack of 8-bit-values. We can only put an 8-bit-value (further referred to as a `byte`,
not to be with the data type `byte`) on top of the stack and we can remove the topmost bit from the stack. We will
refer to the topmost byte as the `top/head` of the stack. The stack is a LIFO (last in, first out) data structure.
The stack is our main tool to manipulate data. We can use an instruction to push a constant onto the stack, then we push another constant onto the stack. Now we can use an add instruction to add the two constants together. Our stack will no longer contain the two constants, but the result of the addition. This would look like this:

```bash
# Stack []
bpush 1
# Stack [1]
bpush 2
# Stack [1, 2]
badd
# Stack [3]
```

Be aware that the stack is a stack of 8-bit-values. When we push a short on the stack, the short consists of 16 bits, so we
will have 2 bytes on our stack now. Here the above example with a short:

```bash
# Stack []
spush 1
# Stack [0, 1]
spush 2
# Stack [0, 1, 0, 2]
sadd
# Stack [0, 3]
```

In this way we could also combine two bytes to a short, or we could use only won spush to push two bytes onto the stack.
This example performs the same operation with bytes, but using spush instead of bpush:

```bash
# Stack []
spush 0x0102
# Stack [1, 2]
badd
# Stack [3]
```

export const ManualSection = ({ 
    opcode,
    id,
    name,
    level,
 }) => (
  <>
    <span id={`code-${opcode}`}>{" "}</span>
    <span id={id}></span>
    {(() => {
        const headerId = `instr-${name}`;
        const contents = (<>
            {`§ ${name} `}
            <code>{name}</code> 
            {" "}
            <em>
                <code>{opcode}</code> 
            </em>
        </>
        );
        switch(level) {
            case "1": return <h1 id={headerId}>{contents}</h1>
            case "2": return <h2 id={headerId}>{contents}</h2>
            case "3": return <h3 id={headerId}>{contents}</h3>
            case "4": return <h4 id={headerId}>{contents}</h4>
            case "5": return <h5 id={headerId}>{contents}</h5>
            case "6": return <h6 id={headerId}>{contents}</h6>
            default: throw new Error(`Invalid level ${level} for instruction ${name} (${opcode})`);
        }
    })()}
  </>
);

Now we will look at the local variable table. The local variable table is a table of 8-bit-values. We can store a byte in
the local variable table and we can load a byte from the local variable table. The local variable table is a table of
bytes, so we can only store a byte one position. If we wan't to store a 16-bit-value, we have to store it in two indices. So a `short` occupies two bytes, an `int` four and so on.

### § 1.1 Pushing constants onto the stack

In the above example we already used some push instructions. Now lets declare them formally.

<ManualSection opcode="0x01" id="1.1.1" name="bpush" level="4" />

A `bpush` instruction pushes a single byte (or any 8-bit-value) onto the stack. It can also be used for a boolean or ubyte.
Syntax: `bpush <u1 value>`, so we have the byte signing a bpush instruction and then directly after that the byte we want to
push onto the stack. Overall instruction length: `2 bytes`.


<ManualSection opcode="0x02" id="1.1.2" name="spush" level="4" />

A `spush` instruction pushes a short (or any 16-bit-value) onto the stack. It can also be used for a ushort.
Syntax: `spush <u2 value>`, so we have the byte signing a spush instruction and then directly after that the short we want to
push onto the stack. Overall instruction length: `3 bytes`.

<ManualSection opcode="0x03" id="1.1.3" name="ipush" level="4" />

An `ipush` instruction pushes an integer (or any 32-bit-value) onto the stack. It can also be used for a float or uint.
Syntax: `ipush <u4 value>`, so we have the byte signing a ipush instruction and then directly after that the integer we want to push onto the stack. Overall instruction length: `5 bytes`.

<ManualSection opcode="0x04" id="1.1.4" name="lpush" level="4" />

A `lpush` instruction pushes a long (or any 64-bit-value) onto the stack. It can also be used for a double or ulong.
Syntax: `lpush <u8 value>`, so we have the byte signing a lpush instruction and then directly after that the long we want to push onto the stack. Overall instruction length: `9 bytes`.

### § 1.2 Loading data from the local variable table

<ManualSection opcode="0x05" id="1.2.1" name="bload" level="4" />

A `bload` instruction loads a byte from the local variable table onto the stack. The index stores the index of the byte in
the local variable table.
Syntax: `bload <u2 index>`
Overall instruction length: `3 bytes`.

<ManualSection opcode="0x06" id="1.2.2" name="sload" level="4" />

A `sload` instruction loads a short from the local variable table onto the stack. The index stores the index of the bottom
byte of the short in the local variable table. The short will be loaded onto the stack. Overall instruction length: `3 bytes`.
Syntax: `sload <u2 index>`
Overall instruction length: `3 bytes`.

<ManualSection opcode="0x07" id="1.2.3" name="iload" level="4" />

A `iload` instruction loads an integer from the local variable table onto the stack. The index stores the index of the bottom
byte of the integer in the local variable table. The integer will be loaded onto the stack.
Syntax: `iload <u2 index>`
Overall instruction length: `3 bytes`.

<ManualSection opcode="0x08" id="1.2.4" name="lload" level="4" />

A `lload` instruction loads a long from the local variable table onto the stack. The index stores the index of the bottom
byte of the long in the local variable table. The long will be loaded onto the stack.
Syntax: `lload <u2 index>`
Overall instruction length: `3 bytes`.

### § 1.3 Storing data in the local variable table

<ManualSection opcode="0x09" id="1.3.1" name="bstore" level="4" />

Store a byte from the stack in the local variable table. The index points to the byte in the local variable table.
Syntax: `bstore <u2 index>` -
Overall instruction length: `3 bytes`.

<ManualSection opcode="0x0A" id="1.3.2" name="sstore" level="4" />

Store a short from the stack in the local variable table. The index points to the bottom byte of the short. The short
occupies two bytes (2 indices) in the local variable table.
Syntax: `sstore <u2 index>`
Overall instruction length: `3 bytes`.

<ManualSection opcode="0x0B" id="1.3.3" name="istore" level="4" />

Store an integer from the stack in the local variable table. The index points to the bottom byte of the integer. The integer
occupies four bytes (4 indices) in the local variable table.
Syntax: `istore <u2 index>`
Overall instruction length: `3 bytes`.

<ManualSection opcode="0x0C" id="1.3.4" name="lstore" level="4" />

Syntax: `lstore <u2 index>` - Store a long from the stack in the local variable table. The index points to the bottom byte of the long. The long occupies eight bytes (8 indices) in the local variable table.

## § 2 Arithmetic operations

### § 2.1 Addition

<ManualSection opcode="0x10" id="2.1.1" name="badd" level="4" />

Add the two bytes from the stack and push the result (byte) onto the stack.
Syntax: `badd`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x11" id="2.1.2" name="sadd" level="4" />

Add the two shorts from the stack and push the result (short) onto the stack.
Syntax: `sadd`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x12" id="2.1.3" name="iadd" level="4" />

Add two integers from the stack and push the result (integer) onto the stack.
Syntax: `iadd`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x13" id="2.1.4" name="ladd" level="4" />

Add two longs from the stack and push the result (long) onto the stack.
Syntax: `ladd`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x14" id="2.1.5" name="fadd" level="4" />

Add two floats from the stack and push the result (float) onto the stack.
Syntax: `fadd`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x15" id="2.1.6" name="dadd" level="4" />

Add two doubles from the stack and push the result (double) onto the stack.
Syntax: `dadd`
Overall instruction length: `1 byte`.

### § 2.2 Subtraction

<ManualSection opcode="0x16" id="2.2.1" name="bsub" level="4" />

Subtract two bytes from the stack and push the result (byte) onto the stack.
Syntax: `bsub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x17" id="2.2.2" name="ssub" level="4" />

Subtract two shorts from the stack and push the result (short) onto the stack.
Syntax: `ssub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x18" id="2.2.3" name="isub" level="4" />

Subtract two integers from the stack and push the result (integer) onto the stack.
Syntax: `isub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x19" id="2.2.4" name="lsub" level="4" />

Subtract two longs from the stack and push the result (long) onto the stack.
Syntax: `lsub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x1A" id="2.2.5" name="fsub" level="4" />

Subtract two floats from the stack and push the result (float) onto the stack.
Syntax: `fsub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x1B" id="2.2.6" name="dsub" level="4" />

Subtract two doubles from the stack and push the result (double) onto the stack.
Syntax: `dsub`
Overall instruction length: `1 byte`.

### § 2.3 Multiplication

Subtract two unsigned bytes from the stack and push the result (unsigned byte) onto the stack.
Syntax: `ubsub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x1D" id="2.2.8" name="ussub" level="4" />

Subtract two unsigned shorts from the stack and push the result (unsigned short) onto the stack.
Syntax: `ussub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x1E" id="2.2.9" name="uisub" level="4" />

Subtract two unsigned integers from the stack and push the result (unsigned integer) onto the stack.
Syntax: `uisub`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x1F" id="2.2.10" name="ulsub" level="4" />

Subtract two unsigned longs from the stack and push the result (unsigned long) onto the stack.
Syntax: `ulsub`
Overall instruction length: `1 byte`.

### § 2.3 Multiplication

<ManualSection opcode="0x20" id="2.3.1" name="bmul" level="4" />

Multiply two bytes from the stack and push the result (byte) onto the stack.
Syntax: `bmul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x21" id="2.3.2" name="smul" level="4" />

Multiply two shorts from the stack and push the result (short) onto the stack.
Syntax: `smul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x22" id="2.3.3" name="imul" level="4" />

Multiply two integers from the stack and push the result (integer) onto the stack.
Syntax: `imul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x23" id="2.3.4" name="lmul" level="4" />

Multiply two longs from the stack and push the result (long) onto the stack.
Syntax: `lmul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x24" id="2.3.5" name="fmul" level="4" />

Multiply two floats from the stack and push the result (float) onto the stack.
Syntax: `fmul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x25" id="2.3.6" name="dmul" level="4" />

Multiply two doubles from the stack and push the result (double) onto the stack.
Syntax: `dmul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x26" id="2.3.7" name="ubmul" level="4" />

Multiply two unsigned bytes from the stack and push the result (unsigned byte) onto the stack.
Syntax: `ubmul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x27" id="2.3.8" name="usmul" level="4" />

Multiply two unsigned shorts from the stack and push the result (unsigned short) onto the stack.
Syntax: `usmul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x28" id="2.3.9" name="uimul" level="4" />

Multiply two unsigned integers from the stack and push the result (unsigned integer) onto the stack.
Syntax: `uimul`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x29" id="2.3.10" name="ulmul" level="4" />

Multiply two unsigned longs from the stack and push the result (unsigned long) onto the stack.
Syntax: `ulmul`
Overall instruction length: `1 byte`.

### § 2.4 Division

<ManualSection opcode="0x2A" id="2.4.1" name="bdiv" level="4" />

Divide two bytes from the stack and push the result (byte) onto the stack.
Syntax: `bdiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x2B" id="2.4.2" name="sdiv" level="4" />

Divide two shorts from the stack and push the result (short) onto the stack.
Syntax: `sdiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x2C" id="2.4.3" name="idiv" level="4" />

Divide two integers from the stack and push the result (integer) onto the stack.
Syntax: `idiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x2D" id="2.4.4" name="ldiv" level="4" />

Divide two longs from the stack and push the result (long) onto the stack.
Syntax: `ldiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x2E" id="2.4.5" name="fdiv" level="4" />

Divide two floats from the stack and push the result (float) onto the stack.
Syntax: `fdiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x2F" id="2.4.6" name="ddiv" level="4" />

Divide two doubles from the stack and push the result (double) onto the stack.
Syntax: `ddiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x30" id="2.4.7" name="ubdiv" level="4" />

Divide two unsigned bytes from the stack and push the result (unsigned byte) onto the stack.
Syntax: `ubdiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x31" id="2.4.8" name="usdiv" level="4" />

Divide two unsigned shorts from the stack and push the result (unsigned short) onto the stack.
Syntax: `usdiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x32" id="2.4.9" name="uidiv" level="4" />

Divide two unsigned integers from the stack and push the result (unsigned integer) onto the stack.
Syntax: `uidiv`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x33" id="2.4.10" name="uldiv" level="4" />

Divide two unsigned longs from the stack and push the result (unsigned long) onto the stack.
Syntax: `uldiv`
Overall instruction length: `1 byte`.

### § 2.5 Modulo

<ManualSection opcode="0x34" id="2.5.1" name="bmod" level="4" />

Modulo two bytes from the stack and push the result (byte) onto the stack.
Syntax: `bmod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x35" id="2.5.2" name="smod" level="4" />

Modulo two shorts from the stack and push the result (short) onto the stack.
Syntax: `smod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x36" id="2.5.3" name="imod" level="4" />

Modulo two integers from the stack and push the result (integer) onto the stack.
Syntax: `imod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x37" id="2.5.4" name="lmod" level="4" />

Modulo two longs from the stack and push the result (long) onto the stack.
Syntax: `lmod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x38" id="2.5.5" name="fmod" level="4" />

Modulo two floats from the stack and push the result (float) onto the stack.
Syntax: `fmod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x39" id="2.5.6" name="dmod" level="4" />

Modulo two doubles from the stack and push the result (double) onto the stack.
Syntax: `dmod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x3A" id="2.5.7" name="ubmod" level="4" />

Modulo two unsigned bytes from the stack and push the result (unsigned byte) onto the stack.
Syntax: `ubmod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x3B" id="2.5.8" name="usmod" level="4" />

Modulo two unsigned shorts from the stack and push the result (unsigned short) onto the stack.
Syntax: `usmod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x3C" id="2.5.9" name="uimod" level="4" />

Modulo two unsigned integers from the stack and push the result (unsigned integer) onto the stack.
Syntax: `uimod`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x3D" id="2.5.10" name="ulmod" level="4" />

Modulo two unsigned longs from the stack and push the result (unsigned long) onto the stack.
Syntax: `ulmod`
Overall instruction length: `1 byte`.

### § 2.6 Negation

<ManualSection opcode="0x3E" id="2.6.1" name="bneg" level="4" />

Negate a byte from the stack and push the result (byte) onto the stack.
Syntax: `bneg`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x3F" id="2.6.2" name="sneg" level="4" />

Syntax: `sneg` - Negate a short from the stack and push the result (short) onto the stack.
Syntax: `sneg`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x40" id="2.6.3" name="ineg" level="4" />

Negate an integer from the stack and push the result (integer) onto the stack.
Syntax: `ineg`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x41" id="2.6.4" name="lneg" level="4" />

Negate a long from the stack and push the result (long) onto the stack.
Syntax: `lneg`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x42" id="2.6.5" name="fneg" level="4" />

Negate a float from the stack and push the result (float) onto the stack.
Syntax: `fneg`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x43" id="2.6.6" name="dneg" level="4" />

Negate a double from the stack and push the result (double) onto the stack.
Syntax: `dneg`
Overall instruction length: `1 byte`.

### § 2.7 Increment

<ManualSection opcode="0x44" id="2.7.1" name="binc" level="4" />

Increment a byte from the stack and push the result (byte) onto the stack.
Syntax: `binc`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x45" id="2.7.2" name="sinc" level="4" />

Increment a short from the stack and push the result (short) onto the stack.
Syntax: `sinc`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x46" id="2.7.3" name="iinc" level="4" />

Increment an integer from the stack and push the result (integer) onto the stack.
Syntax: `iinc`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x47" id="2.7.4" name="linc" level="4" />

Increment a long from the stack and push the result (long) onto the stack.
Syntax: `linc`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x48" id="2.7.5" name="finc" level="4" />

Increment a float from the stack and push the result (float) onto the stack.
Syntax: `finc`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x49" id="2.7.6" name="dinc" level="4" />

Increment a double from the stack and push the result (double) onto the stack.
Syntax: `dinc`
Overall instruction length: `1 byte`.

### § 2.8 Decrement

<ManualSection opcode="0x4A" id="2.8.1" name="bdec" level="4" />

Decrement a byte from the stack and push the result (byte) onto the stack.
Syntax: `bdec`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x4B" id="2.8.2" name="sdec" level="4" />

Decrement a short from the stack and push the result (short) onto the stack.
Syntax: `sdec`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x4C" id="2.8.3" name="idec" level="4" />

Decrement an integer from the stack and push the result (integer) onto the stack.
Syntax: `idec`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x4D" id="2.8.4" name="ldec" level="4" />

Decrement a long from the stack and push the result (long) onto the stack.
Syntax: `ldec`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x4E" id="2.8.5" name="fdec" level="4" />

Decrement a float from the stack and push the result (float) onto the stack.
Syntax: `fdec`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x4F" id="2.8.6" name="ddec" level="4" />

Decrement a double from the stack and push the result (double) onto the stack.
Syntax: `ddec`
Overall instruction length: `1 byte`.

## § 3 Bitwise Expressions

### § 3.1 Bitwise and

<ManualSection opcode="0x50" id="3.1.1" name="band" level="4" />

Bitwise and two bytes from the stack and push the result (byte) onto the stack.
Can also be used for boolean and ubyte.
Syntax: `band`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x51" id="3.1.2" name="sand" level="4" />

Bitwise and two shorts from the stack and push the result (short) onto the stack.
Can also be used for char and ushort.
Syntax: `sand`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x52" id="3.1.3" name="iand" level="4" />

Bitwise and two integers from the stack and push the result (integer) onto the stack.
Can also be used for float and uint.
Syntax: `iand`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x53" id="3.1.4" name="land" level="4" />

Bitwise and two longs from the stack and push the result (long) onto the stack.
Can also be used for double and ulong.
Syntax: `land`
Overall instruction length: `1 byte`.

### § 3.2 Bitwise or

<ManualSection opcode="0x54" id="3.2.1" name="bor" level="4" />

Bitwise or two bytes from the stack and push the result (byte) onto the stack.
Can also be used for boolean and ubyte.
Syntax: `bor`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x55" id="3.2.2" name="sor" level="4" />

Bitwise or two shorts from the stack and push the result (short) onto the stack.
Can also be used for char and ushort.
Syntax: `sor`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x56" id="3.2.3" name="ior" level="4" />

Bitwise or two integers from the stack and push the result (integer) onto the stack.
Can also be used for float and uint.
Syntax: `ior`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x57" id="3.2.4" name="lor" level="4" />

Bitwise or two longs from the stack and push the result (long) onto the stack.
Can also be used for double and ulong.
Syntax: `lor`
Overall instruction length: `1 byte`.

### § 3.3 Bitwise xor

<ManualSection opcode="0x58" id="3.3.1" name="bxor" level="4" />

Bitwise xor two bytes from the stack and push the result (byte) onto the stack.
Can also be used for boolean and ubyte.
Syntax: `bxor`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x59" id="3.3.2" name="sxor" level="4" />

Bitwise xor two shorts from the stack and push the result (short) onto the stack.
Can also be used for char and ushort.
Syntax: `sxor`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x5A" id="3.3.3" name="ixor" level="4" />

Bitwise xor two integers from the stack and push the result (integer) onto the stack.
Can also be used for float and uint.
Syntax: `ixor`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x5B" id="3.3.4" name="lxor" level="4" />

Bitwise xor two longs from the stack and push the result (long) onto the stack.
Can also be used for double and ulong.
Syntax: `lxor`
Overall instruction length: `1 byte`.

### § 3.4 Bitwise not

<ManualSection opcode="0x5C" id="3.4.1" name="bnot" level="4" />

Invert the byte on top of the stack and push the result (byte) onto the stack.
Syntax: `bnot`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x5D" id="3.4.2" name="snot" level="4" />

Invert the short on top of the stack and push the result (short) onto the stack.
Syntax: `snot`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x5E" id="3.4.3" name="inot" level="4" />

Invert the integer on top of the stack and push the result (integer) onto the stack.
Syntax: `inot`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x5F" id="3.4.4" name="lnot" level="4" />

Invert the long on top of the stack and push the result (long) onto the stack.
Syntax: `lnot`
Overall instruction length: `1 byte`.

### § 3.5 Bitwise shift left

<ManualSection opcode="0x60" id="3.5.1" name="bshl" level="4" />

Bitwise shift left a byte from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the byte below defines the byte to shift.
Can also be used for boolean and ubyte.
Syntax: `bshl`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x61" id="3.5.2" name="sshl" level="4" />

Bitwise shift left a short from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the short below defines the short to shift.
Can also be used for char and ushort.
Syntax: `sshl`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x62" id="3.5.3" name="ishl" level="4" />

Bitwise shift left an integer from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the integer below defines the integer to shift.
Can also be used for float and uint.
Syntax: `ishl`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x63" id="3.5.4" name="lshl" level="4" />

Bitwise shift left a long from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the long below defines the long to shift.
Can also be used for double and ulong.
Syntax: `lshl`
Overall instruction length: `1 byte`.

### § 3.6 Bitwise shift right

<ManualSection opcode="0x64" id="3.6.1" name="bshr" level="4" />

Bitwise shift right a byte from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the byte below defines the byte to shift.
Can also be used for boolean and ubyte.
Syntax: `bshr`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x65" id="3.6.2" name="sshr" level="4" />

Bitwise shift right a short from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the short below defines the short to shift.
Can also be used for char and ushort.
Syntax: `sshr`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x66" id="3.6.3" name="ishr" level="4" />

Bitwise shift right an integer from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the integer below defines the integer to shift.
Can also be used for float and uint.
Syntax: `ishr`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x67" id="3.6.4" name="lshr" level="4" />

Bitwise shift right a long from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the long below defines the long to shift.
Can also be used for double and ulong.
Syntax: `lshr`
Overall instruction length: `1 byte`.

### § 3.7 Bitwise shift right unsigned

<ManualSection opcode="0x68" id="3.7.1" name="bshru" level="4" />

Bitwise shift right unsigned a byte from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the byte below defines the byte to shift.
Can also be used for boolean and ubyte.
Syntax: `bshru`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x69" id="3.7.2" name="sshr" level="4" />

Bitwise shift right unsigned a short from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the short below defines the short to shift.
Can also be used for char and ushort.
Syntax: `sshr`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x6A" id="3.7.3" name="ishru" level="4" />

Bitwise shift right unsigned an integer from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the integer below defines the integer to shift.
Can also be used for float and uint.
Syntax: `ishru`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x6B" id="3.7.4" name="lshru" level="4" />

Bitwise shift right unsigned a long from the stack and push the result onto the stack.
The top byte of the stack defines the number of bits to shift, the long below defines the long to shift.
Can also be used for double and ulong.
Syntax: `lshru`
Overall instruction length: `1 byte`.

## § 4 CMP Expressions

### § 4.1 CMP

<ManualSection opcode="0x70" id="4.1.1" name="bcmp" level="4" />

Compare two bytes from the stack and push the result onto the stack.
If the top byte is greater than the second, the result will be -1, if they are equal, the result will be 0 and if the
top byte is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top byte is greater than the second
0 0 0 0 0 0 0 1 // 1, the top byte is equal to the second
0 0 0 0 0 0 1 0 // 2, the top byte is smaller than the second
```

Syntax: `bcmp`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x71" id="4.1.2" name="scmp" level="4" />

Compare two shorts from the stack and push the result onto the stack.
If the top short is greater than the second, the result will be -1, if they are equal, the result will be 0 and if the
top short is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top short is greater than the second
0 0 0 0 0 0 0 1 // 1, the top short is equal to the second
0 0 0 0 0 0 1 0 // 2, the top short is smaller than the second
```

Syntax: `scmp`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x72" id="4.1.3" name="icmp" level="4" />

Compare two integers from the stack and push the result onto the stack.
If the top integer is greater than the second, the result will be -1, if they are equal, the result will be 0 and if the
top integer is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top integer is greater than the second
0 0 0 0 0 0 0 1 // 1, the top integer is equal to the second
0 0 0 0 0 0 1 0 // 2, the top integer is smaller than the second
```

Syntax: `icmp`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x73" id="4.1.4" name="lcmp" level="4" />

Compare two longs from the stack and push the result onto the stack.
If the top long is greater than the second, the result will be -1, if they are equal, the result will be 0 and if the
top long is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top long is greater than the second
0 0 0 0 0 0 0 1 // 1, the top long is equal to the second
0 0 0 0 0 0 1 0 // 2, the top long is smaller than the second
```

Syntax: `lcmp`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x74" id="4.1.5" name="fcmp" level="4" />

Compare two floats from the stack and push the result onto the stack.
If the top float is greater than the second, the result will be -1, if they are equal, the result will be 0 and if the
top float is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top float is greater than the second
0 0 0 0 0 0 0 1 // 1, the top float is equal to the second
0 0 0 0 0 0 1 0 // 2, the top float is smaller than the second
```

Syntax: `fcmp`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x75" id="4.1.6" name="dcmp" level="4" />

Compare two doubles from the stack and push the result onto the stack.

If the top double is greater than the second, the result will be -1, if they are equal, the result will be 0 and if
the top double is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top double is greater than the second
0 0 0 0 0 0 0 1 // 1, the top double is equal to the second
0 0 0 0 0 0 1 0 // 2, the top double is smaller than the second
```

Syntax: `dcmp`
Overall instruction length: `1 byte`.

<ManualSection opcode="0x76" id="4.1.7" name="ubcmp" level="4" />

Compare two unsigned bytes from the stack and push the result onto the stack.

If the top unsigned byte is greater than the second, the result will be -1, if they are equal, the result will be 0 and if the top unsigned byte is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top unsigned byte is greater than the second
0 0 0 0 0 0 0 1 // 1, the top unsigned byte is equal to the second
0 0 0 0 0 0 1 0 // 2, the top unsigned byte is smaller than the second
```

Syntax: `ubcmp`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x77" id="4.1.8" name="uscmp" level="4" />

Compare two unsigned shorts from the stack and push the result onto the stack.

If the top unsigned short is greater than the second, the result will be -1, if they are equal, the result will be 0
and if the top unsigned short is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top unsigned short is greater than the second
0 0 0 0 0 0 0 1 // 1, the top unsigned short is equal to the second
0 0 0 0 0 0 1 0 // 2, the top unsigned short is smaller than the second
```

Syntax: `uscmp`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x78" id="4.1.9" name="uicmp" level="4" />

Compare two unsigned integers from the stack and push the result onto the stack.

If the top unsigned integer is greater than the second, the result will be -1, if they are equal, the result will be 0
and if the top unsigned integer is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top unsigned integer is greater than the second
0 0 0 0 0 0 0 1 // 1, the top unsigned integer is equal to the second
0 0 0 0 0 0 1 0 // 2, the top unsigned integer is smaller than the second
```

Syntax: `uicmp`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x79" id="4.1.10" name="ulcmp" level="4" />

Compare two unsigned longs from the stack and push the result onto the stack.

If the top unsigned long is greater than the second, the result will be -1, if they are equal, the result will be 0
and if the top unsigned long is smaller than the second, the result will be -1. The result will be a byte.

```txt
0 0 0 0 0 0 0 0 // 0, the top unsigned long is greater than the second
0 0 0 0 0 0 0 1 // 1, the top unsigned long is equal to the second
0 0 0 0 0 0 1 0 // 2, the top unsigned long is smaller than the second
```

Syntax: `ulcmp`

Overall instruction length: `1 byte`.

### Comparison to boolean

You can achieve the same result using jumps, but these are shortcuts for that. These are very commonly used
combinations, so for performance reasons, these are included as instructions.

These instructions convert cmp results to booleans.

<ManualSection opcode="0x7A" id="4.2.1" name="clt" level="4" />

Compare two values from the stack and push the result onto the stack. Uses the result of the compare operator.

Will return 1 (`00000001`) only if the top value is smaller than the second value.
(so if the cmp result is `00000010`)

Syntax: `clt`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x7B" id="4.2.2" name="cle" level="4" />

Compare two values from the stack and push the result onto the stack. Uses the result of the compare operator.

Will return 1 (`00000001`) if the top value is smaller than or equal to the second value.
(so if the cmp result is `00000010` or `00000001`)

Syntax: `cle`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x7C" id="4.2.3" name="ceq" level="4" />

Compare two values from the stack and push the result onto the stack. Uses the result of the compare operator.

Will return 1 (`00000001`) if the top value is equal to the second value.
(so if the cmp result is `00000001`)

Syntax: `ceq`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x7D" id="4.2.4" name="cne" level="4" />

Compare two values from the stack and push the result onto the stack. Uses the result of the compare operator.

Will return 1 (`00000001`) if the top value is not equal to the second value.
(so if the cmp result is `00000000` or `00000010`)

Syntax: `cne`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x7E" id="4.2.5" name="cge" level="4" />

Compare two values from the stack and push the result onto the stack. Uses the result of the compare operator.

Will return 1 (`00000001`) if the top value is greater than or equal to the second value.

(so if the cmp result is `00000000` or `00000001`)

Syntax: `cge`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x7F" id="4.2.6" name="cgt" level="4" />

Compare two values from the stack and push the result onto the stack. Uses the result of the compare operator.

Will return 1 (`00000001`) if the top value is greater than the second value.
(so if the cmp result is `00000000`)

Syntax: `cgt`

Overall instruction length: `1 byte`.

## § 5 Control flow

### § 5.1 Jumping

<ManualSection opcode="0x80" id="5.1.1" name="jmp" level="4" />

Jump to the instruction at the given address.

Syntax: `jmp <u4 address>`
Overall instruction length: `5 bytes`.

<ManualSection opcode="0x81" id="5.1.2" name="jz" level="4" />

Jump to the instruction at the given address if the the comparison result is 1 (00000001) (the two values are equal).

Syntax: `jz <u4 address>`

Overall instruction length: `5 bytes`.

<ManualSection opcode="0x82" id="5.1.3" name="jnz" level="4" />

Jump to the instruction at the given address if the the comparison result is not 1 (00000001) (the two values are not equal).

Syntax: `jnz <u4 address>`

Overall instruction length: `5 bytes`.

<ManualSection opcode="0x83" id="5.1.4" name="je" level="4" />

Jump to the instruction at the given address if the the comparison result is 1 (00000001) (the two compared values are equal).

Syntax: `je <u4 address>`

Overall instruction length: `5 bytes`.

<ManualSection opcode="0x84" id="5.1.5" name="jne" level="4" />

Jump to the instruction at the given address if the the comparison result is not 1 (00000001) (the two values are not equal).

Syntax: `jne <u4 address>`

Overall instruction length: `5 bytes`.

<ManualSection opcode="0x85" id="5.1.6" name="jg" level="4" />

Jump to the instruction at the given address if the the comparison result is 0 (00000000) (the first value is greater than the second).

This has no actual byte code, it is here for completeness. Use [`jz`](#-512-jz) instead, as it does the same.

Syntax: `jg <u4 address>`

Overall instruction length: `5 bytes`.

<ManualSection opcode="0x86" id="5.1.7" name="jge" level="4" />

Jump to the instruction at the given address if the the comparison result is 0 (00000000) or 1 (00000001) (the first value is greater than or equal to the second).

Syntax: `jge <u4 address>`

Overall instruction length: `5 bytes`.

<ManualSection opcode="0x87" id="5.1.8" name="jl" level="4" />

Jump to the instruction at the given address if the the comparison result is 2 (00000010) (the first value is smaller than the second).

Syntax: `jl <u4 address>`

Overall instruction length: `5 bytes`.

<ManualSection opcode="0x88" id="5.1.9" name="jle" level="4" />

Jump to the instruction at the given address if the the comparison result is 2 (00000010) or 1 (00000001) (the first value is smaller than or equal to the second).

Syntax: `jle <u4 address>`

Overall instruction length: `5 bytes`.

### § 5.2 Returning

<ManualSection opcode="0x90" id="5.2.1" name="ret" level="4" />

Return from the current method.

Syntax: `ret`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x91" id="5.2.2" name="bret" level="4" />

Set the return value to a byte and return value (one byte).

**This instruction only sets the return value, it does not return from the method.**

_Can also be used for boolean and ubyte._

Syntax: `bret`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x92" id="5.2.3" name="sret" level="4" />

Set the return value to a short and return value (two bytes).

**This instruction only sets the return value, it does not return from the method.**

_Can also be used for char and ushort._

Syntax: `sret`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x93" id="5.2.4" name="iret" level="4" />

Set the return value to an integer and return value (four bytes).

**This instruction only sets the return value, it does not return from the method.**

_Can also be used for float and uint._

Syntax: `iret`

Overall instruction length: `1 byte`.

<ManualSection opcode="0x94" id="5.2.5" name="lret" level="4" />

Set the return value to a long and return value (eight bytes).

**This instruction only sets the return value, it does not return from the method.**

_Can also be used for double and ulong._

Syntax: `lret`

## § 6 Misc

<MiscSection opcode="0xA0" id="6.1" name="nop" level="4" />

Does nothing.

Syntax: `nop`

Overall instruction length: `1 byte`.

### § 7.2 pop

<ManualSection opcode="0xA1" id="7.2.1" name="bpop" level="4" />

Pop the top byte from the stack.

Syntax: `pop`

Overall instruction length: `1 byte`.

<ManualSection opcode="0xA2" id="7.2.2" name="spop" level="4" />

Pop the top two bytes from the stack.

Syntax: `spop`

Overall instruction length: `1 byte`.

<ManualSection opcode="0xA3" id="7.2.3" name="ipop" level="4" />

Pop the top four bytes from the stack.

Syntax: `ipop`

Overall instruction length: `1 byte`.

<ManualSection opcode="0xA4" id="7.2.4" name="lpop" level="4" />

Pop the top eight bytes from the stack.

Syntax: `lpop`

Overall instruction length: `1 byte`.

### § 7.3 dup

<ManualSection opcode="0xA5" id="7.3.1" name="bdup" level="4" />

Duplicate the top byte on the stack.

Could be used to duplicate a byte, boolean or ubyte.

Syntax: `bdup`

Overall instruction length: `1 byte`.

<ManualSection opcode="0xA6" id="7.3.2" name="sdup" level="4" />

Duplicate the top 2-byte element on the stack.

Could be used to duplicate a short, char or ushort.

Syntax: `sdup`

Overall instruction length: `1 byte`.

<ManualSection opcode="0xA7" id="7.3.3" name="idup" level="4" />

Duplicate the top 4-byte element on the stack.

Could be used to duplicate an integer, float or uint.

Syntax: `idup`

Overall instruction length: `1 byte`.

<ManualSection opcode="0xA8" id="7.3.4" name="ldup" level="4" />

Duplicate the top 8-byte element on the stack.

Could be used to duplicate a long, double or ulong.

Syntax: `ldup`

Overall instruction length: `1 byte`.

<ManualSection opcode="0xA9" id="7.3.5" name="dup" level="4" />

Perform a primitive cast.
The following byte defines the type to cast to.

You can split this byte into two 4-bit numbers (0-15). The first 4-bit number defines the type to cast from, the second 4-bit number defines the type to cast to.

This table shows the available types:

| Type     | (Hex) | (Decimal) | (Binary) |
| -------- | ----- | --------- | -------- |
| `byte`   | `0x0` | `0`       | `0000`   |
| `short`  | `0x1` | `1`       | `0001`   |
| `int`    | `0x2` | `2`       | `0010`   |
| `long`   | `0x3` | `3`       | `0011`   |
| `ubyte`  | `0x4` | `4`       | `0100`   |
| `ushort` | `0x5` | `5`       | `0101`   |
| `uint`   | `0x6` | `6`       | `0110`   |
| `ulong`  | `0x7` | `7`       | `0111`   |
| `float`  | `0x8` | `8`       | `1000`   |
| `double` | `0x9` | `9`       | `1001`   |

For example, if you want to cast a byte to a short, you would use `0x01` (`0b00010001`). You can read this like this:
We want to cast `0x` `0` _to_ `1`, so we use `0x01`.

Syntax: `pcast <u1 type>`

Overall instruction length: `2 bytes`.

### § 8 Invoking methods

<ManualSection opcode="0xB0" id="8.1" name="invoke_static" level="4" />

Invoke a method. Target method **must** be static!

Syntax: `invoke <u4 constant>`

The constant should be an utf-8 constant, containing a qualified method name.

Overall instruction length: `5 bytes`.

<ManualSection opcode="0xB1" id="8.2" name="invoke_instance" level="4" />

Call a method on an object. Target method **must not** be static!

Synthax: `call <u4 constant>`

The constant should be an utf-8 constant, containing a qualified method name.`

Overall instruction length: `5 bytes`

The arguments are taken from right to left from the stack (so you can )

8 bytes from the stack will be taken as address. **The arguments will be taken first!**

## § 9 Field access

<MiscSection opcode="0xB2" id="9.1" name="load_field_static" level="4" />

Load a static field value

Synthax: `load_field_static <u4 constant>`

The constant should be an utf-8 constant, containing a qualified field name.`

Overall instruction length: `5 bytes`

<MiscSection opcode="0xB3" id="9.2" name="load_field_instance" level="4" />

Load an instance field value

Synthax: `load_field_instance <u4 constant>`

The constant should be an utf-8 constant, containing a qualified field name.`

Overall instruction length: `5 bytes`

8 bytes from the stack will be taken as address.

<ManualSection opcode="0xB4" id="9.3" name="bload_array" level="4" />

Load a byte from an array

Synthax: `bload_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

Will put the result (`1 byte`) on top of the stack

<ManualSection opcode="0xB5" id="9.4" name="sload_array" level="4" />

Load a short from an array

Synthax: `sload_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

Will put the result (`2 byte`) on top of the stack

<ManualSection opcode="0xB6" id="9.5" name="iload_array" level="4" />

Load an integer from an array

Synthax: `iload_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

Will put the result (`4 byte`) on top of the stack

<ManualSection opcode="0xB7" id="9.6" name="lload_array" level="4" />

Load a long from an array

Synthax: `lload_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

Will put the result (`8 byte`) on top of the stack

<MiscSection opcode="0xB8" id="9.7" name="store_static" level="4" />

Store a static field value

Synthax: `call <u4 constant>`
The constant should be an utf-8 constant, containing a qualified field name.`

Overall instruction length: `5 bytes`

<MiscSection opcode="0xB9" id="9.8" name="store_instance" level="4" />

Store a static field value

Synthax: `call <u4 constant>`

The constant should be an utf-8 constant, containing a qualified field name.`

Overall instruction length: `5 bytes`

8 bytes from the stack will be taken as address.

### § 9.9 `bstore_array` _`0xBA`_

Store a byte in an array

Synthax: `bstore_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

The value (`1 byte`) is taken from the stack

### § 9.10 `sstore_array` _`0xBB`_

Store a short in an array

Synthax: `sstore_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

The value (`2 byte`) is taken from the stack

### § 9.11 `istore_array` _`0xBC`_

Store an integer in an array

Synthax: `istore_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

The value (`4 byte`) is taken from the stack

### § 9.12 `lstore_array` _`0xBD`_

Store a long in an array

Synthax: `lstore_array`

Overall instruction length: `1 byte`

The index (`4 byte`) is taken from the stack

The array (`8 byte`) is taken from the stack

The value (`8 byte`) is taken from the stack

## § 10 Creating objects and arrays

### § 10.1 `new_object` _`0xC0`_

Create a new object

Synthax: `new_object <u4 constant>`

The constant should be an utf-8 constant, containing a qualified constructor name.

Overall instruction length: `5 bytes`

### § 10.2 `new_array` _`0xC1`_

Create a new array

Synthax: `new_array <u4 constant>`

The constant should be an utf-8 constant, containing a qualified type name.

Overall instruction length: `5 bytes`

The length (`4 byte`) is taken from the stack

## § 11 Throwing exceptions

### § 11.1 `throw` _`0xC2`_

Throw an exception

Synthax: `throw`

Overall instruction length: `1 byte`

The exception (`8 byte`) is taken from the stack

<!--

TODO: Are these even needed? Are they a security risk?

## § 9 Global variables

### § 9.1 Load global variable

#### § 9.1.2 `bloadg` _`(0xB0)`_

Load a global variable onto the stack.

Syntax: `bloadg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

Will put the result (`1 byte`) on top of the stack

#### § 9.1.2 `sloadg` _`(0xB1)`_

Load a global variable onto the stack.

Syntax: `sloadg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

Will put the result (`2 byte`) on top of the stack

#### § 9.1.3 `iloadg` _`(0xB2)`_

Load a global variable onto the stack.

Syntax: `iloadg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

Will put the result (`4 byte`) on top of the stack

#### § 9.1.4 `lloadg` _`(0xB3)`_

Load a global variable onto the stack.

Syntax: `lloadg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

Will put the result (`8 byte`) on top of the stack

### § 9.2 Store global variable

#### § 9.2.1 `bstoreg` _`(0xB4)`_

Store a byte from the stack into a global variable.

Syntax: `bstoreg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

The value (`1 byte`) is taken from the stack

#### § 9.2.2 `sstoreg` _`(0xB5)`_

Store a short from the stack into a global variable.

Syntax: `sstoreg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

The value (`2 byte`) is taken from the stack

#### § 9.2.3 `istoreg` _`(0xB6)`_

Store an integer from the stack into a global variable.

Syntax: `istoreg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

The value (`4 byte`) is taken from the stack

#### § 9.2.4 `lstoreg` _`(0xB7)`_

Store a long from the stack into a global variable.

Syntax: `lstoreg`

Overall instruction length: `1 byte`.

The address (`8 byte`) is taken from the stack

The value (`8 byte`) is taken from the stack

-->
